C51 COMPILER V9.00   CMD                                                                   06/08/2020 09:01:32 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE CMD
OBJECT MODULE PLACED IN .\Objects\cmd.obj
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE cmd.c LARGE BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\cmd.lst) OBJECT(.\Ob
                    -jects\cmd.obj)

line level    source

   1          #include "rtx.h"
   2          #include "stc8.h"
   3          #include "adc.h"
   4          #include "cmd.h"
   5          #include "pll.h"
   6          #include "utily.h"
   7          #include "pwm.h"
   8          #include "dac.h"
   9          
  10          unsigned char tx_pwr = 0;
  11          unsigned char tx_enable = 0;
  12          
  13          sbit tx_en = P1^0;
  14          
  15          unsigned char rply[9];
  16          unsigned char rply_len = 0;
  17          unsigned char cmd[5];
  18          unsigned char cmd_backup[5];
  19          unsigned char cmd_len = 0;
  20          
  21          idata unsigned char tx_ctrl_table[64];
  22          idata signed char tx_pwr_table[40];
  23          
  24          void Cmd_InitTable()
  25          {
  26   1              tx_ctrl_table[0] = 795;
  27   1      
  28   1      
  29   1      
  30   1              tx_ctrl_table[63] = 490;
  31   1      
  32   1              tx_pwr_table[0] = 0;
  33   1      
  34   1      
  35   1          tx_pwr_table[0] = 0;
  36   1      }
  37          
  38          void Cmd_set(unsigned char content)
  39          {
  40   1              if(cmd_len == 5)
  41   1                      cmd_len = 0;
  42   1      
  43   1              cmd[cmd_len] = content;
  44   1              cmd_len++;
  45   1      }
  46          
  47          void Cmd_Del(unsigned char size)
  48          {
  49   1              unsigned char remain,i;
  50   1              if(cmd_len < size)
  51   1                      size = cmd_len;
  52   1      
  53   1              remain = cmd_len - size;
  54   1              for(i=0;i<remain;i++)
C51 COMPILER V9.00   CMD                                                                   06/08/2020 09:01:32 PAGE 2   

  55   1                      cmd_backup[i] = cmd[size+i];
  56   1              for(i=0;i<remain;i++)
  57   1                      cmd[i] = cmd_backup[i];
  58   1              cmd_len =  remain;
  59   1      }
  60          
  61          unsigned char Cmd_IsNew()
  62          {
  63   1              if(cmd_len < 3)
  64   1                      return 0;
  65   1      
  66   1              if(cmd[0] == 0xa1)
  67   1              {
  68   2                      if((cmd[2] != 0x00) && (cmd[2] != 0x0a))
  69   2                      {
  70   3                              Cmd_Del(3);
  71   3                              return 0;
  72   3                      }
  73   2      
  74   2                      if(cmd_len < 4)
  75   2                              return 0;
  76   2      
  77   2                      if(cmd[3] != CRC(cmd,3))
  78   2                      {
  79   3                              Cmd_Del(3);
  80   3                              return 0;
  81   3                      }
  82   2                      else return 1;
  83   2              }
  84   1              else if(cmd[0] == 0xa2)
  85   1              {
  86   2                      if((cmd[2] != 0x01) && (cmd[2] != 0x02))
  87   2                      {
  88   3                              Cmd_Del(3);
  89   3                              return 0;
  90   3                      }
  91   2      
  92   2                      if(cmd_len < 5)
  93   2                              return 0;
  94   2      
  95   2                      if(cmd[4] != CRC(cmd,4))
  96   2                      {
  97   3                              Cmd_Del(3);
  98   3                              return 0;
  99   3                      }
 100   2                      else return 1; 
 101   2              }
 102   1              else if(cmd[0] == 0xa3)
 103   1              {
 104   2                      if((cmd[2] != 0x01) && (cmd[2] != 0x81))
 105   2                      {
 106   3                              Cmd_Del(3);
 107   3                              return 0;
 108   3                      }
 109   2      
 110   2                      if(cmd_len < 5)
 111   2                              return 0;
 112   2      
 113   2                      if(cmd[4] != CRC(cmd,4))
 114   2                      {
 115   3                              Cmd_Del(3);
 116   3                              return 0;
C51 COMPILER V9.00   CMD                                                                   06/08/2020 09:01:32 PAGE 3   

 117   3                      }
 118   2                      else return 1; 
 119   2              }
 120   1              else
 121   1              {
 122   2                      Cmd_Del(3);
 123   2                      return 0;
 124   2              }
 125   1      }
 126          
 127          
 128          void Cmd_reply()
 129          {
 130   1              unsigned int i;
 131   1              for(i=0;i<rply_len;i++)
 132   1                      RTX_Send(rply[i]);
 133   1      
 134   1              rply_len = 0;
 135   1      }
 136          
 137          void Cmd_ack(unsigned char size)
 138          {
 139   1              unsigned int i;
 140   1              for(i=0;i<size;i++)
 141   1                      RTX_Send(cmd[i]);
 142   1      }
 143          
 144          void BuildPwrRply()
 145          {       
 146   1              unsigned char var = GetLO1Voltage();
 147   1      
 148   1              rply[0] = 0xa1;
 149   1              rply[1] = 0x05;
 150   1              rply[2] = 0x00;
 151   1      
 152   1              rply[3] = tx_pwr_table[var];
 153   1      
 154   1              if(PLL_IsTxLocked() == 1)
 155   1                      rply[4] = 5;
 156   1              else rply[4] = 4;
 157   1      
 158   1              if(PLL_IsTxLocked() == 1)
 159   1                      rply[5] = 5;
 160   1              else rply[5] = 4;
 161   1      
 162   1              if(PLL_IsRxLocked() == 1)
 163   1                      rply[6] = 5;
 164   1              else rply[6] = 4;
 165   1      
 166   1              rply[7] = CRC(rply,7);
 167   1              rply_len = 8;
 168   1      }
 169          
 170          void BuildLOLockRply()
 171          {
 172   1              rply[0] = 0xa1;
 173   1              rply[1] = 0x02;
 174   1              rply[2] = 0x01;
 175   1      
 176   1              rply[3] = PLL_IsRxLocked();
 177   1              rply[3] = (rply[2] << 1);
 178   1      
C51 COMPILER V9.00   CMD                                                                   06/08/2020 09:01:32 PAGE 4   

 179   1              rply[3] |= PLL_IsTxLocked();
 180   1              rply[3] = (rply[2] << 1);
 181   1              rply[3] |= PLL_IsTxLocked();
 182   1      
 183   1              rply[4] = CRC(rply,4);
 184   1              rply_len = 5;
 185   1      }
 186          
 187          void BuildTxPwrRply()
 188          {
 189   1              unsigned char var = GetLO1Voltage();
 190   1      
 191   1              rply[0] = 0xa1;
 192   1              rply[1] = 0x02;
 193   1              rply[2] = 0x02;
 194   1      
 195   1              rply[3] = tx_pwr_table[var];
 196   1      
 197   1              rply[4] = CRC(rply,4);
 198   1              rply_len = 5;
 199   1      }
 200          
 201          void BuildTxLO1PwrRply()
 202          {
 203   1              rply[0] = 0xa1;
 204   1              rply[1] = 0x02;
 205   1              rply[2] = 0x03;
 206   1      
 207   1              if(PLL_IsTxLocked() == 1)
 208   1                      rply[3] = 5;
 209   1              else rply[3] = 4;
 210   1      
 211   1              rply[4] = CRC(rply,4);
 212   1              rply_len = 5;
 213   1      }
 214          
 215          void BuildTxLO2PwrRply()
 216          {
 217   1              rply[0] = 0xa1;
 218   1              rply[1] = 0x02;
 219   1              rply[2] = 0x04;
 220   1      
 221   1              if(PLL_IsTxLocked() == 1)
 222   1                      rply[3] = 5;
 223   1              else rply[3] = 4;
 224   1      
 225   1              rply[4] = CRC(rply,4);
 226   1              rply_len = 5;
 227   1      }
 228          
 229          void BuildRxLO3Rply()
 230          {
 231   1              rply[0] = 0xa1;
 232   1              rply[1] = 0x02;
 233   1              rply[2] = 0x05;
 234   1      
 235   1              if(PLL_IsRxLocked() == 1)
 236   1                      rply[3] = 5;
 237   1              else rply[3] = 4;
 238   1      
 239   1              rply[4] = CRC(rply,4);
 240   1              rply_len = 5;   
C51 COMPILER V9.00   CMD                                                                   06/08/2020 09:01:32 PAGE 5   

 241   1      }
 242          
 243          void BuildAllStateRply()
 244          {
 245   1              rply[0] = 0xa1;
 246   1              rply[1] = 0x06;
 247   1              rply[2] = 0x06;
 248   1      
 249   1              rply[3] = PLL_IsRxLocked();
 250   1              rply[3] = (rply[2] << 1);
 251   1      
 252   1              rply[3] |= PLL_IsTxLocked();
 253   1              rply[3] = (rply[2] << 1);
 254   1              rply[3] |= PLL_IsTxLocked();
 255   1      
 256   1              rply[4] = tx_pwr/2;
 257   1      
 258   1              rply[5] = GetLO1Voltage();
 259   1              rply[6] = GetLO1Voltage();
 260   1              rply[7] = GetLO3Voltage();
 261   1      
 262   1              rply[8] = CRC(rply,8);
 263   1              rply_len = 9;   
 264   1      }
 265          
 266          void BuildTxEnableRply()
 267          {
 268   1              rply[0] = 0xa1;
 269   1              rply[1] = 0x02;
 270   1              rply[2] = 0x07;
 271   1      
 272   1              rply[3] = tx_enable;
 273   1      
 274   1              rply[4] = CRC(rply,4);
 275   1              rply_len = 5;
 276   1      }
 277          
 278          void BuildTxPowerATTRply()
 279          {
 280   1              rply[0] = 0xa1;
 281   1              rply[1] = 0x02;
 282   1              rply[2] = 0x08;
 283   1      
 284   1              rply[3] = tx_pwr;
 285   1      
 286   1              rply[4] = CRC(rply,4);
 287   1              rply_len = 5;
 288   1      }
 289          
 290          void BuildHWVerisonRply()
 291          {
 292   1              rply[0] = 0xa1;
 293   1              rply[1] = 0x02;
 294   1              rply[2] = 0x09;
 295   1      
 296   1              rply[3] = 1;
 297   1      
 298   1              rply[4] = CRC(rply,4);
 299   1              rply_len = 5;
 300   1      }
 301          
 302          void BuildSWVersionRply()
C51 COMPILER V9.00   CMD                                                                   06/08/2020 09:01:32 PAGE 6   

 303          {
 304   1              rply[0] = 0xa1;
 305   1              rply[1] = 0x02;
 306   1              rply[2] = 0x0a;
 307   1      
 308   1              rply[3] = 1;
 309   1      
 310   1              rply[4] = CRC(rply,4);
 311   1              rply_len = 5;
 312   1      }
 313          
 314          void process_a1(unsigned char cmd_wd)
 315          {
 316   1              switch(cmd_wd)
 317   1              {
 318   2                      case 0x00:
 319   2                              BuildPwrRply();
 320   2                              break;
 321   2                      case 0x01:
 322   2                              BuildLOLockRply();
 323   2                              break;
 324   2                      case 0x02:
 325   2                              BuildTxPwrRply();       
 326   2                              break;
 327   2                      case 0x03:
 328   2                              BuildTxLO1PwrRply();
 329   2                              break;
 330   2                      case 0x04:
 331   2                              BuildTxLO2PwrRply();
 332   2                              break;
 333   2                      case 0x05:
 334   2                              BuildRxLO3Rply();
 335   2                              break;
 336   2                      case 0x06:
 337   2                              BuildAllStateRply();
 338   2                              break;
 339   2                      case 0x07:
 340   2                              BuildTxEnableRply();
 341   2                              break;
 342   2                      case 0x08:
 343   2                              BuildTxPowerATTRply();
 344   2                              break;
 345   2                      case 0x09:
 346   2                              BuildHWVerisonRply();
 347   2                              break;
 348   2                      case 0x0a:
 349   2                              BuildSWVersionRply();
 350   2                              break;
 351   2                      default:
 352   2                              break;
 353   2              }
 354   1      
 355   1              Cmd_Del(4);
 356   1              if(rply_len != 0)
 357   1                      Cmd_reply();
 358   1      }
 359          
 360          void process_a2(unsigned char cmd_wd)
 361          {
 362   1              if(cmd_wd == 0x01)
 363   1              {
 364   2                       tx_enable = cmd[3];
C51 COMPILER V9.00   CMD                                                                   06/08/2020 09:01:32 PAGE 7   

 365   2                       tx_en = tx_enable;
 366   2                       Cmd_ack(5);
 367   2              }
 368   1              else if(cmd_wd == 0x02)
 369   1              {
 370   2                      tx_pwr = cmd[3];
 371   2                      WriteI2C(tx_ctrl_table[cmd[3]]);        
 372   2                      Cmd_ack(5);
 373   2              }
 374   1              Cmd_Del(5);
 375   1      }
 376          
 377          void process_a3(unsigned char cmd_wd)
 378          {
 379   1              char var;
 380   1      
 381   1              if(cmd_wd == 0x01)
 382   1              {
 383   2                      var = cmd[3] & 0x7f;
 384   2                      PLL_Adjust(var);
 385   2                      Cmd_ack(5);
 386   2              }
 387   1              else if(cmd_wd == 0x81)
 388   1              {
 389   2                      var = cmd[3] & 0x7f;
 390   2                      var = -var;
 391   2                      PLL_Adjust(var);
 392   2                      Cmd_ack(5);
 393   2              }
 394   1      
 395   1              Cmd_Del(5);
 396   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1362    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     23       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =    104    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
